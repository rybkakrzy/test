using NUnit.Framework;
using System;
using System.Globalization;

namespace YourApp.Tests
{
    [TestFixture]
    [Parallelizable(ParallelScope.All)]
    public class ToWordsTests
    {
        private IFormatterPolasService _sut;

        [SetUp]
        public void SetUp()
        {
            _sut = new FormatterPolasService();
        }

        // ========================
        // EXCEPTION CASES
        // ========================

        [Test]
        public void ToWords_WhenAmountIsNull_ThrowsArgumentNullException()
        {
            object? amount = null;

            var ex = Assert.Throws<ArgumentNullException>(() => _sut.ToWords(amount));

            Assert.Multiple(() =>
            {
                Assert.That(ex, Is.Not.Null);
                Assert.That(ex!.ParamName, Is.EqualTo("amount"));
            });
        }

        [Test]
        public void ToWords_WhenAmountNotConvertible_ThrowsArgumentException()
        {
            var ex = Assert.Throws<ArgumentException>(() => _sut.ToWords(new object()));

            Assert.Multiple(() =>
            {
                Assert.That(ex, Is.Not.Null);
                Assert.That(ex!.Message, Does.Contain("cannot be converted to a number"));
            });
        }

        // ========================
        // ZERO CASES
        // ========================

        [TestCase(0, "zero złotych, 00 groszy")]
        [TestCase(0.00, "zero złotych, 00 groszy")]
        public void ToWords_WhenZero_ReturnsCorrectText(decimal input, string expected)
        {
            var result = _sut.ToWords(input);

            Assert.That(result, Is.EqualTo(expected));
        }

        // ========================
        // SIMPLE NUMBERS
        // ========================

        [TestCase(1, "jeden złoty, 00 groszy")]
        [TestCase(2, "dwa złote, 00 groszy")]
        [TestCase(5, "pięć złotych, 00 groszy")]
        [TestCase(12, "dwanaście złotych, 00 groszy")]
        [TestCase(21, "dwadzieścia jeden złotych, 00 groszy")]
        [TestCase(101, "sto jeden złotych, 00 groszy")]
        public void ToWords_WhenInteger_ReturnsCorrectPolishGrammar(decimal input, string expected)
        {
            var result = _sut.ToWords(input);

            Assert.That(result, Is.EqualTo(expected));
        }

        // ========================
        // FRACTIONS / GROSZE
        // ========================

        [TestCase(1.01, "jeden złoty, 01 grosz")]
        [TestCase(1.02, "jeden złoty, 02 grosze")]
        [TestCase(1.05, "jeden złoty, 05 groszy")]
        [TestCase(2.50, "dwa złote, 50 groszy")]
        [TestCase(12.99, "dwanaście złotych, 99 groszy")]
        public void ToWords_WhenDecimal_ReturnsCorrectWithGrosze(decimal input, string expected)
        {
            var result = _sut.ToWords(input);

            Assert.That(result, Is.EqualTo(expected));
        }

        // ========================
        // LARGE NUMBERS
        // ========================

        [TestCase(1000, "jeden tysiąc złotych, 00 groszy")]
        [TestCase(2000, "dwa tysiące złotych, 00 groszy")]
        [TestCase(5000, "pięć tysięcy złotych, 00 groszy")]
        [TestCase(1000000, "jeden milion złotych, 00 groszy")]
        [TestCase(2000000, "dwa miliony złotych, 00 groszy")]
        [TestCase(5000000, "pięć milionów złotych, 00 groszy")]
        public void ToWords_WhenLargeNumber_ReturnsExpected(decimal input, string expected)
        {
            var result = _sut.ToWords(input);

            Assert.That(result, Is.EqualTo(expected));
        }

        // ========================
        // CULTURE INDEPENDENCE
        // ========================

        [Test]
        public void ToWords_ShouldBeCultureInvariant()
        {
            var previous = CultureInfo.CurrentCulture;
            try
            {
                CultureInfo.CurrentCulture = new CultureInfo("en-US");

                var result = _sut.ToWords(1234.56m);

                Assert.That(result, Is.EqualTo("jeden tysiąc dwieście trzydzieści cztery złote, 56 groszy"));
            }
            finally
            {
                CultureInfo.CurrentCulture = previous;
            }
        }

        // ========================
        // EDGE CASES
        // ========================

        [TestCase(1.999, "jeden złoty, 99 groszy")] // sprawdzenie zaokrąglenia groszy
        [TestCase(999999999.99, "dziewięćset dziewięćdziesiąt dziewięć milionów dziewięćset dziewięćdziesiąt dziewięć tysięcy dziewięćset dziewięćdziesiąt dziewięć złotych, 99 groszy")]
        public void ToWords_WhenEdgeCases_ReturnsExpected(decimal input, string expected)
        {
            var result = _sut.ToWords(input);

            Assert.That(result, Is.EqualTo(expected));
        }
    }
}


---------------------------


using NUnit.Framework;
using System;

namespace YourApp.Tests
{
    [TestFixture]
    public class BankAccountFormatterTests
    {
        private BankAccountFormatter _sut;

        [SetUp]
        public void SetUp()
        {
            _sut = new BankAccountFormatter();
        }

        // ============================
        // NEGATIVE CASES
        // ============================

        [TestCase(null)]
        [TestCase("")]
        [TestCase(" ")]
        public void FormatBankAccountNumber_WhenNullOrWhitespace_ThrowsArgumentException(string input)
        {
            // Act
            var ex = Assert.Throws<ArgumentException>(() => _sut.FormatBankAccountNumber(input));

            // Assert
            Assert.Multiple(() =>
            {
                Assert.That(ex, Is.Not.Null);
                Assert.That(ex!.Message, Does.Contain("nie może być pusty"));
            });
        }

        [TestCase("1")]
        public void FormatBankAccountNumber_WhenTooShort_ThrowsArgumentException(string input)
        {
            // Act
            var ex = Assert.Throws<ArgumentException>(() => _sut.FormatBankAccountNumber(input));

            // Assert
            Assert.Multiple(() =>
            {
                Assert.That(ex, Is.Not.Null);
                Assert.That(ex!.Message, Does.Contain("co najmniej 2"));
            });
        }

        // ============================
        // POSITIVE CASES
        // ============================

        [TestCase("12", "12 ")]                       // minimal case
        [TestCase("123", "12 3")]                     // 1 digit in rest
        [TestCase("12345", "12 345")]                 // 3 digits in rest
        [TestCase("123456", "12 3456")]               // exactly 4 digits in rest
        [TestCase("1234567", "12 3456 7")]            // 5 digits in rest
        [TestCase("1234567890", "12 3456 7890")]      // multiple full groups
        [TestCase("12345678901234", "12 3456 7890 1234")] // multiple groups
        [TestCase("12 34 56 78", "12 3456 78")]       // input with spaces
        public void FormatBankAccountNumber_WhenValid_ReturnsExpected(string input, string expected)
        {
            // Act
            var result = _sut.FormatBankAccountNumber(input);

            // Assert
            Assert.Multiple(() =>
            {
                Assert.That(result, Is.Not.Null);
                Assert.That(result, Is.EqualTo(expected));
            });
        }

        [Test]
        public void FormatBankAccountNumber_WhenAlreadyFormatted_IsIdempotent()
        {
            // Arrange
            var input = "12345678901234567890";
            var once = _sut.FormatBankAccountNumber(input);

            // Act
            var twice = _sut.FormatBankAccountNumber(once);

            // Assert
            Assert.Multiple(() =>
            {
                Assert.That(twice, Is.EqualTo(once));
                Assert.That(twice.Split(" ").Length, Is.GreaterThan(1));
            });
        }
    }
}



---------------------------------

[Authorize(Roles = Roles.BasicPreset)]
[ApiController]
[Route("api/[controller]")]
public class BalanceDocumentController : ControllerBase
{
    private readonly ICmkowiNHelperService _cmkowiNHelperService;
    private readonly ILogger<BalanceDocumentController> _logger;

    public BalanceDocumentController(
        ICmkowiNHelperService cmkowiNHelperService,
        ILogger<BalanceDocumentController> logger)
    {
        _cmkowiNHelperService = cmkowiNHelperService;
        _logger = logger;
    }

    [HttpGet("zsw")]
    [ProducesResponseType(typeof(ZswBalanceDocument), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status403Forbidden)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<ZswBalanceDocument>> GetZswBalanceDocument([FromQuery] string barcodeId)
    {
        if (!IsValidInput(barcodeId, 50)) // ograniczenie długości
            return BadRequest("Invalid barcodeId.");

        try
        {
            var result = await _cmkowiNHelperService.GetZswBalanceDocument(barcodeId);
            return result is not null ? Ok(result) : NotFound();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error while fetching ZSW balance document for barcodeId {BarcodeId}", barcodeId);
            return StatusCode(StatusCodes.Status500InternalServerError, "Unexpected error occurred.");
        }
    }

    [HttpGet("pkkb")]
    [ProducesResponseType(typeof(KkbBalanceDocument), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status403Forbidden)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<KkbBalanceDocument>> GetPkkbBalanceDocument([FromQuery] string documentId)
    {
        if (!IsValidInput(documentId, 50)) // ograniczenie długości
            return BadRequest("Invalid documentId.");

        try
        {
            var result = await _cmkowiNHelperService.GetPkkbBalanceDocument(documentId);
            return result is not null ? Ok(result) : NotFound();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error while fetching PKKB balance document for documentId {DocumentId}", documentId);
            return StatusCode(StatusCodes.Status500InternalServerError, "Unexpected error occurred.");
        }
    }

    // 🔐 Walidacja parametrów wejściowych – prosta i szybka ochrona
    private static bool IsValidInput(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input)) return false;
        if (input.Length > maxLength) return false;

        // Zezwalamy tylko na litery, cyfry i kilka bezpiecznych znaków
        return input.All(c => char.IsLetterOrDigit(c) || c is '-' or '_' or '.');
    }
}




import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormArray, FormGroup, FormControl } from '@angular/forms';

interface Option {
  key: string;
  value: string;
}

@Component({
  selector: 'app-dynamic-checkbox-form',
  templateUrl: './dynamic-checkbox-form.component.html'
})
export class DynamicCheckboxFormComponent implements OnInit {

  form!: FormGroup;

  options: Option[] = [
    { key: 'A', value: 'Option A' },
    { key: 'B', value: 'Option B' },
    { key: 'C', value: 'Option C' },
    { key: 'D', value: 'Another choice' }
  ];

  preselectedKeys: string[] | null = ['A', 'C'];

  // Input for search
  searchControl = new FormControl('');

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      selections: this.buildSelectionsArray(this.options, this.preselectedKeys)
    });
  }

  private buildSelectionsArray(options: Option[], preselectedKeys: string[] | null): FormArray {
    return this.fb.array(
      options.map(opt => {
        const isChecked = preselectedKeys?.includes(opt.key) ?? false;
        return this.fb.control(isChecked);
      })
    );
  }

  get selectionsFormArray(): FormArray {
    return this.form.get('selections') as FormArray;
  }

  // Filter options by search input
  get filteredOptions(): Option[] {
    const term = this.searchControl.value?.toLowerCase() ?? '';
    return this.options.filter(opt => opt.value.toLowerCase().includes(term));
  }

  getSelectedKeys(): string[] {
    return this.form.value.selections
      .map((checked: boolean, i: number) => checked ? this.options[i].key : null)
      .filter((v: string | null) => v !== null) as string[];
  }

  onSubmit(): void {
    const selectedKeys = this.getSelectedKeys();
    console.log('Send to API:', selectedKeys);
  }
}



<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <!-- Search input -->
  <input
    type="text"
    [formControl]="searchControl"
    placeholder="Search options..."
  />

  <div formArrayName="selections">
    <div *ngFor="let option of filteredOptions; let i = index">
      <label>
        <input type="checkbox" [formControlName]="i" />
        {{ option.value }}
      </label>
    </div>
  </div>

  <button type="submit">Submit</button>
</form>

------------------------


import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormArray, FormGroup } from '@angular/forms';

interface Option {
  key: string;
  value: string;
}

@Component({
  selector: 'app-dynamic-checkbox-form',
  templateUrl: './dynamic-checkbox-form.component.html'
})
export class DynamicCheckboxFormComponent implements OnInit {

  form!: FormGroup;

  // Lista opcji (np. z konfiguracji, stała lub pobrana z API)
  options: Option[] = [
    { key: 'A', value: 'Option A' },
    { key: 'B', value: 'Option B' },
    { key: 'C', value: 'Option C' }
  ];

  // Dane np. z API – zaznaczone pola (symulacja)
  preselectedKeys: string[] | null = ['A', 'C'];
  // Jeśli brak danych -> ustaw null albo pustą tablicę

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      selections: this.buildSelectionsArray(this.options, this.preselectedKeys)
    });
  }

  /**
   * Build FormArray of checkbox controls
   * @param options - list of available options
   * @param preselectedKeys - keys that should be checked by default
   */
  private buildSelectionsArray(options: Option[], preselectedKeys: string[] | null): FormArray {
    return this.fb.array(
      options.map(opt => {
        const isChecked = preselectedKeys?.includes(opt.key) ?? false;
        return this.fb.control(isChecked);
      })
    );
  }

  get selectionsFormArray(): FormArray {
    return this.form.get('selections') as FormArray;
  }

  getSelectedKeys(): string[] {
    return this.form.value.selections
      .map((checked: boolean, i: number) => checked ? this.options[i].key : null)
      .filter((v: string | null) => v !== null) as string[];
  }

  onSubmit(): void {
    const selectedKeys = this.getSelectedKeys();
    console.log('Send to API:', selectedKeys);
  }
}


<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <div formArrayName="selections">
    <div *ngFor="let option of options; let i = index">
      <label>
        <input type="checkbox" [formControlName]="i" />
        {{ option.value }}
      </label>
    </div>
  </div>

  <button type="submit">Submit</button>
</form>
