[Authorize(Roles = Roles.BasicPreset)]
[ApiController]
[Route("api/[controller]")]
public class BalanceDocumentController : ControllerBase
{
    private readonly ICmkowiNHelperService _cmkowiNHelperService;
    private readonly ILogger<BalanceDocumentController> _logger;

    public BalanceDocumentController(
        ICmkowiNHelperService cmkowiNHelperService,
        ILogger<BalanceDocumentController> logger)
    {
        _cmkowiNHelperService = cmkowiNHelperService;
        _logger = logger;
    }

    [HttpGet("zsw")]
    [ProducesResponseType(typeof(ZswBalanceDocument), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status403Forbidden)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<ZswBalanceDocument>> GetZswBalanceDocument([FromQuery] string barcodeId)
    {
        if (!IsValidInput(barcodeId, 50)) // ograniczenie d≈Çugo≈õci
            return BadRequest("Invalid barcodeId.");

        try
        {
            var result = await _cmkowiNHelperService.GetZswBalanceDocument(barcodeId);
            return result is not null ? Ok(result) : NotFound();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error while fetching ZSW balance document for barcodeId {BarcodeId}", barcodeId);
            return StatusCode(StatusCodes.Status500InternalServerError, "Unexpected error occurred.");
        }
    }

    [HttpGet("pkkb")]
    [ProducesResponseType(typeof(KkbBalanceDocument), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status403Forbidden)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<KkbBalanceDocument>> GetPkkbBalanceDocument([FromQuery] string documentId)
    {
        if (!IsValidInput(documentId, 50)) // ograniczenie d≈Çugo≈õci
            return BadRequest("Invalid documentId.");

        try
        {
            var result = await _cmkowiNHelperService.GetPkkbBalanceDocument(documentId);
            return result is not null ? Ok(result) : NotFound();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error while fetching PKKB balance document for documentId {DocumentId}", documentId);
            return StatusCode(StatusCodes.Status500InternalServerError, "Unexpected error occurred.");
        }
    }

    // üîê Walidacja parametr√≥w wej≈õciowych ‚Äì prosta i szybka ochrona
    private static bool IsValidInput(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input)) return false;
        if (input.Length > maxLength) return false;

        // Zezwalamy tylko na litery, cyfry i kilka bezpiecznych znak√≥w
        return input.All(c => char.IsLetterOrDigit(c) || c is '-' or '_' or '.');
    }
}




import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormArray, FormGroup, FormControl } from '@angular/forms';

interface Option {
  key: string;
  value: string;
}

@Component({
  selector: 'app-dynamic-checkbox-form',
  templateUrl: './dynamic-checkbox-form.component.html'
})
export class DynamicCheckboxFormComponent implements OnInit {

  form!: FormGroup;

  options: Option[] = [
    { key: 'A', value: 'Option A' },
    { key: 'B', value: 'Option B' },
    { key: 'C', value: 'Option C' },
    { key: 'D', value: 'Another choice' }
  ];

  preselectedKeys: string[] | null = ['A', 'C'];

  // Input for search
  searchControl = new FormControl('');

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      selections: this.buildSelectionsArray(this.options, this.preselectedKeys)
    });
  }

  private buildSelectionsArray(options: Option[], preselectedKeys: string[] | null): FormArray {
    return this.fb.array(
      options.map(opt => {
        const isChecked = preselectedKeys?.includes(opt.key) ?? false;
        return this.fb.control(isChecked);
      })
    );
  }

  get selectionsFormArray(): FormArray {
    return this.form.get('selections') as FormArray;
  }

  // Filter options by search input
  get filteredOptions(): Option[] {
    const term = this.searchControl.value?.toLowerCase() ?? '';
    return this.options.filter(opt => opt.value.toLowerCase().includes(term));
  }

  getSelectedKeys(): string[] {
    return this.form.value.selections
      .map((checked: boolean, i: number) => checked ? this.options[i].key : null)
      .filter((v: string | null) => v !== null) as string[];
  }

  onSubmit(): void {
    const selectedKeys = this.getSelectedKeys();
    console.log('Send to API:', selectedKeys);
  }
}



<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <!-- Search input -->
  <input
    type="text"
    [formControl]="searchControl"
    placeholder="Search options..."
  />

  <div formArrayName="selections">
    <div *ngFor="let option of filteredOptions; let i = index">
      <label>
        <input type="checkbox" [formControlName]="i" />
        {{ option.value }}
      </label>
    </div>
  </div>

  <button type="submit">Submit</button>
</form>

------------------------


import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormArray, FormGroup } from '@angular/forms';

interface Option {
  key: string;
  value: string;
}

@Component({
  selector: 'app-dynamic-checkbox-form',
  templateUrl: './dynamic-checkbox-form.component.html'
})
export class DynamicCheckboxFormComponent implements OnInit {

  form!: FormGroup;

  // Lista opcji (np. z konfiguracji, sta≈Ça lub pobrana z API)
  options: Option[] = [
    { key: 'A', value: 'Option A' },
    { key: 'B', value: 'Option B' },
    { key: 'C', value: 'Option C' }
  ];

  // Dane np. z API ‚Äì zaznaczone pola (symulacja)
  preselectedKeys: string[] | null = ['A', 'C'];
  // Je≈õli brak danych -> ustaw null albo pustƒÖ tablicƒô

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      selections: this.buildSelectionsArray(this.options, this.preselectedKeys)
    });
  }

  /**
   * Build FormArray of checkbox controls
   * @param options - list of available options
   * @param preselectedKeys - keys that should be checked by default
   */
  private buildSelectionsArray(options: Option[], preselectedKeys: string[] | null): FormArray {
    return this.fb.array(
      options.map(opt => {
        const isChecked = preselectedKeys?.includes(opt.key) ?? false;
        return this.fb.control(isChecked);
      })
    );
  }

  get selectionsFormArray(): FormArray {
    return this.form.get('selections') as FormArray;
  }

  getSelectedKeys(): string[] {
    return this.form.value.selections
      .map((checked: boolean, i: number) => checked ? this.options[i].key : null)
      .filter((v: string | null) => v !== null) as string[];
  }

  onSubmit(): void {
    const selectedKeys = this.getSelectedKeys();
    console.log('Send to API:', selectedKeys);
  }
}


<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <div formArrayName="selections">
    <div *ngFor="let option of options; let i = index">
      <label>
        <input type="checkbox" [formControlName]="i" />
        {{ option.value }}
      </label>
    </div>
  </div>

  <button type="submit">Submit</button>
</form>
